include "../../jl5/parse/jl5_ppg.cup"

package polyglot.ext.esj.parse;

import java.util.*;

import polyglot.ext.esj.types.ESJTypeSystem;
import polyglot.ext.esj.ast.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl5.parse.*;

parser Grm extends polyglot.ext.jl5.parse.Grm {:
    public final ESJTypeSystem ts;
    public final ESJNodeFactory nf;
    String currClassName;

    public void currClassName(String n) {
    	   this.currClassName = n;
    }
	
    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (ESJTypeSystem) t;
        nf = (ESJNodeFactory) n;
    }

    // define separate methods for each universal/existential expressions
    // also define relational-logic counterparts, to be used by external solvers...
    public List<JL5MethodDecl> defineESJExtraMethods(JL5MethodDecl methodDecl) throws Exception {
              List extraMtds = new TypedList(new LinkedList(), ClassMember.class, false);

	      // find the pred_expression subexprs within the body and mark them	    
	      List predExprs = getPredExprsWithinBody(methodDecl);
	      FlagAnnotations fl = makeFlagAnnotations();
	      List mStmts = new TypedList(new LinkedList(), Stmt.class, false);
	      List logmStmts = new TypedList(new LinkedList(), Stmt.class, false);
              mStmts.add(nf.JL5Return(null, nf.BooleanLit(null,true)));
              logmStmts.add(nf.JL5Return(null, nf.NullLit(null)));

	      for (ESJQuantifyExpr a : (List<ESJQuantifyExpr>)predExprs) { 
	          a.parentMethod(methodDecl);
    	      	  String quantMtdId = a.id();
		  FormulaBinary.Operator quantKind = a.quantKind();
		  String quantVarN = a.quantVarN();
		  Expr quantList = a.quantListExpr();
                  ESJQuantifyClauseExpr quantExpr = a.quantClauseExpr();
		  List quantVarD = a.quantVarD();
		  boolean quantKindIsaCount = quantKind == FormulaBinary.ONE ||
		  	    quantKind == FormulaBinary.LONE;
	      	  List stmts = new TypedList(new LinkedList(), Stmt.class, false);
		  if (quantKindIsaCount) {
	      	      LocalDecl d1 = nf.JL5LocalDecl(null, makeFlagAnnotations(), nf.CanonicalTypeNode(null, ts.Int()), "quantCount", nf.IntLit(null, IntLit.INT, 0));
		      stmts.add(d1);		  
		  }
		  stmts.addAll(mStmts);
	      	  ESJPredMethodDecl extraMtd = nf.ESJPredMethodDecl(null, fl,
	                                          nf.CanonicalTypeNode(null,ts.Boolean()), 
						  methodDecl.name() + "_" + quantMtdId, 
						  methodDecl.formals(), 
						  new TypedList(new LinkedList(), TypeNode.class, false), 
						  nf.Block(null, stmts), methodDecl.throwTypes(),
						  quantMtdId, 
						  quantKind, quantVarN, quantVarD, 
						  quantList, quantExpr); 
                  
                  extraMtds.add(extraMtd);

             }

	     FormulaBinary.Operator quantKind = FormulaBinary.ALL;
	     String quantVarN = null;
	     List quantVarD = null;
		  
	     if (predExprs.size() > 0) {
	     	ESJQuantifyExpr a = (ESJQuantifyExpr) predExprs.get(0);
	 	quantKind = a.quantKind();
	 	quantVarN = a.quantVarN();
		quantVarD = a.quantVarD();
	     }

	     ESJLogPredMethodDecl extraLogMtd = nf.ESJLogPredMethodDecl(null, fl,
	                                          nf.CanonicalTypeNode(null,ts.Boolean()), //typeForName("polyglot.ext.esj.tologic.LogFormula")),
						  methodDecl.name() + "_log", 
						  methodDecl.formals(), 
						  new TypedList(new LinkedList(), TypeNode.class, false), 
						  this.makeESJLogPredBlock(((Return) methodDecl.body().statements().get(0)).expr(),quantVarD,quantVarN), methodDecl.throwTypes(), false); 
                  
             extraMtds.add(extraLogMtd);

	     return extraMtds;
    }


    public List getPredExprsWithinBody(JL5MethodDecl methodDecl) {
	      List predSubExprs = new TypedList(new LinkedList(), ESJQuantifyExpr.class, false);
	      Expr fullExpr = ((Return)(methodDecl.body().statements().get(0))).expr();
	      getPredExprsWithinBodyHelper(fullExpr,predSubExprs);	      
	      return predSubExprs;
     }

     public void getPredExprsWithinBodyHelper(Expr n,List predSubExprs) {
     	    if (n instanceof Binary) {
	          getPredExprsWithinBodyHelper(((Binary)n).left(),predSubExprs);
	          getPredExprsWithinBodyHelper(((Binary)n).right(),predSubExprs);
	    } else if (n instanceof ESJQuantifyExpr) {
	          predSubExprs.add(n);
	    }
     }

     public ESJEnsuredMethodDecl makeESJEnsuredMethodDecl(Position pos, FlagAnnotations flags,
				  TypeNode returnType, String name,
				  List formals, List throwTypes, Block body, 
				  List paramTypes, Expr ensuresExpr) throws Exception {
	    FlagAnnotations fl = makeFlagAnnotations();
	    TypeNode cftn = new JL5Name(this, null, "Throwable").toType();
	    JL5Formal catchFormal = this.nf.JL5Formal(null, fl, this.array(cftn, 0), "rte");
       	    return this.nf.ESJEnsuredMethodDecl(pos, flags, returnType, name, formals, throwTypes, body, paramTypes, ensuresExpr, catchFormal); 
     }    

     public ESJLogPredMethodDecl makeFallbackMtd(ESJEnsuredMethodDecl methodDecl) throws SemanticException {
	    FlagAnnotations fl = makeFlagAnnotations(); 
	    //System.out.println(methodDecl.body());
	    List args = new TypedList(new LinkedList(), Expr.class, false);
	    List args2 = new TypedList(new LinkedList(), Expr.class, false);
	    List args3 = new TypedList(new LinkedList(), Expr.class, false);
	    args.add(nf.StringLit(null,"fallback initiated..."));

	    Expr probFormula = methodDecl.ensuresExpr();
	    LocalDecl d1 = nf.JL5LocalDecl(null, fl, nf.CanonicalTypeNode(null, ts.Boolean()), "problem", probFormula);
	    args2.add(nf.Local(null,"problem"));
	    args3.add(nf.This(null));
	    args3.add(nf.Local(null,"problem"));
	    List l = new TypedList(new LinkedList(), Stmt.class, false);
	    LocalDecl d2 = nf.LocalDecl(null, fl.classicFlags(), nf.CanonicalTypeNode(null, ts.Boolean()), "isSatisfiable", nf.Call(null, nf.CanonicalTypeNode(null, ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "solve", args3));
	    l.add(nf.Eval(null,nf.Call(null, nf.Field(null, nf.CanonicalTypeNode(null, ts.typeForName("java.lang.System")),"out"), "println", args)));
	    l.add(d1);
	    l.add(d2);
	    l.add(nf.Eval(null,nf.Call(null, nf.Field(null, nf.CanonicalTypeNode(null, ts.typeForName("java.lang.System")),"out"), "println", args2)));
	    l.add(nf.JL5Assert(null, nf.Local(null,"isSatisfiable"), nf.StringLit(null, "Formula UNSAT! Recovery failed...")));
	    l.add(nf.Return(null, nf.Local(null,"isSatisfiable")));
     	    return nf.ESJLogPredMethodDecl(null, fl,
	                                          nf.CanonicalTypeNode(null,ts.Boolean()),
						  methodDecl.name() + "_fallback", 
						  methodDecl.formals(), 
						  new TypedList(new LinkedList(), TypeNode.class, false), 						  
						  nf.Block(null,l),
						  methodDecl.throwTypes(),true); 

     }

     public ESJQuantifyExpr makeESJQuantifyExpr(Position pos, FormulaBinary.Operator quantKind, TypeNode tn, String quantVarN, Expr quantListExpr, Expr quantClauseExpr) throws Exception {
	    
	    // FIXME
	    if (tn.toString().equals("polyglot.ext.esj.primitives.ESJInteger")) {
	       	 tn = nf.CanonicalTypeNode(null, ts.Int());
	    }
	    FlagAnnotations fl = makeFlagAnnotations(); 
	    List quantVarD = new TypedList(new LinkedList(), LocalDecl.class, false);
	    quantVarD.add(nf.JL5LocalDecl(null, fl, tn, quantVarN, null));

	    return this.nf.ESJQuantifyExpr(pos,quantKind,quantVarN, quantVarD, quantListExpr,quantClauseExpr);
}


     public Block makeESJLogPredBlock(Expr expr, List quantVarD, String quantVarN) throws SemanticException {

	    FlagAnnotations fl = makeFlagAnnotations(); 
	    //FIXME
	    Expr newExpr = makeESJLogPredBlockHelper(expr);
	    List l = new TypedList(new LinkedList(), Stmt.class, false);
	    if (quantVarN != null) {
	    //LocalDecl d = nf.ESJQuantVarLocalDecl(null, fl, nf.CanonicalTypeNode(null, ts.Int()), quantVarN, nf.IntLit(null, IntLit.INT, 0))
	    LocalDecl d = nf.ESJQuantVarLocalDecl(null, fl, nf.CanonicalTypeNode(null, ((JL5LocalDecl) quantVarD.get(0)).declType()), quantVarN, null);
	    	    l.add((Stmt) d);		
            }
	    l.add(nf.Return(null, newExpr));
	    return nf.Block(null, l); 
     }    

     public Expr makeESJLogPredBlockHelper(Expr e) {
     	    if (e instanceof FormulaBinary) {
	       	  Binary b = (Binary) e;
	       	  return nf.FormulaBinary(null, b.left(), b.operator(), b.right());
	    } else if (e instanceof CmpBinary) {
	       	  Binary b = (Binary) e;
	       	  return nf.CmpBinary(null, b.left(), b.operator(), b.right());
	    } else if (e instanceof Binary) {
	       	  Binary b = (Binary) e;
	       	  return nf.Binary(null, b.left(), b.operator(), b.right());
	    } else if (e instanceof ESJQuantifyExpr) {
	       	  ESJQuantifyExpr q = (ESJQuantifyExpr) e;
	       	  return nf.ESJLogQuantifyExpr(null, q.quantKind(), q.quantVarN(), q.quantVarD(), q.quantListExpr(), q.quantClauseExpr().expr());
	    } else {
	      	   return e;
	    }
     }

     FlagAnnotations makeFlagAnnotations() {
     	      List<Flags> fs = new ArrayList<Flags>();
	      fs.add(Flags.NONE);
     	      return makeFlagAnnotations(fs);
     }

     FlagAnnotations makeFlagAnnotations(List<Flags> fs) {
	      FlagAnnotations fl2 = new FlagAnnotations(); 
	      for (Flags f: fs)
              	  fl2.classicFlags(f);
              fl2.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
	      return fl2;
     }	      

:};

terminal Token INVARIANTS;
terminal Token PREDICATE;
terminal Token ENSURES;
terminal Token ENSURED;
terminal Token SOME;
terminal Token ALL;
terminal Token NO;
terminal Token ONE;
terminal Token LONE;

non terminal JL5MethodDecl pred_method_header;
non terminal ESJEnsuredMethodDecl ensured_method_header;
non terminal List pred_method_declaration, ensured_method_declaration, class_invariant_declaration;
non terminal Block pred_method_body, pred_block;
non terminal List pred_block_statements;
non terminal Return pred_statement;
non terminal ESJQuantifyExpr pred_expression;
non terminal Expr quantify_expression, quant_list_expr, ensures_opt, ensures_clause;
non terminal FormulaBinary.Operator quant_kind;
non terminal ESJEnsuredClassDecl ensured_class_declaration;
non terminal Expr predicate_expr;
non terminal Expr or_predicate_expr;
non terminal Expr orPredExpr_opt;
non terminal Expr and_predicate_expr;
non terminal Expr andPredExpr_opt;
non terminal Expr equality_predicate_expr;
non terminal Binary.Operator equality_predicate_op;
non terminal Expr relational_predicate_expr;
non terminal Binary.Operator relational_predicate_op;
non terminal Expr additive_predicate_expr;
non terminal Binary.Operator additive_predicate_op;
non terminal Expr multiplicative_predicate_expr;
non terminal Expr unary_predicate_expr;
non terminal Expr atomic_predicate_expr;
non terminal Expr formal_or_field_access;
non terminal Receiver field_prefix;
non terminal Expr predicate_literal;
non terminal TypeNode esj_type;



start with goal;

// Here begins the ESJ grammar extensions and modifications

extend class_member_declaration ::=
        pred_method_declaration:a 
	   {: RESULT = a; :}
     |  ensured_method_declaration:a 
	   {: RESULT = a; :}
	   ;

// PART1:      ESJPredMethod

pred_method_declaration ::=
        pred_method_header:a pred_method_body:b 
	   {: JL5MethodDecl mainMtdDecl = (JL5MethodDecl) a.body(b);
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
              l.add(mainMtdDecl);
	      l.addAll(parser.defineESJExtraMethods(mainMtdDecl));
              RESULT = l; 
	   :}
	   ;


pred_method_header ::=
        PREDICATE:z modifiers_or_annotations_opt:a BOOLEAN:b IDENTIFIER:c LPAREN 
                formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f
            {: RESULT = parser.nf.JL5MethodDecl(null, a, parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), e.intValue()), c.getIdentifier(), d, f, null, new TypedList(new LinkedList(), TypeNode.class, false)); 
            :}
    	    ;

pred_method_body ::=
        pred_block:a 
	   {:  RESULT = a;  :}
	   ;

pred_block ::=
        LBRACE:n pred_block_statements:a RBRACE:d 
           {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
	   ;

pred_block_statements ::= 
        pred_statement:a
           {: List l = new TypedList(new LinkedList(), Stmt.class, false);
              l.add(a);
              RESULT = l; 
	   :}
	   ;

pred_statement ::=
        predicate_expr:a 
	   {: RESULT = parser.nf.JL5Return(parser.pos(a), a); :}
	   ;

quantify_expression ::=
        quant_kind:a esj_type:g name:b quant_list_expr:d OR:e equality_predicate_expr:f
       	   {: if (a == FormulaBinary.NO) {
	          a = FormulaBinary.ALL;
		  f = parser.nf.Unary(null, Unary.NOT, f);
	       }
             if (d == null) { 
	         d = parser.nf.ESJQuantifyTypeExpr(null,g);
             }
	     RESULT = parser.makeESJQuantifyExpr(null,a,g,b.toString(),d,f); 
	   :} 
	   ;

quant_list_expr ::=	
        COLON primary_no_new_array:a
           {:  
	      RESULT = a;  
	   :}
     |    {:  RESULT = null;  :};

esj_type ::=

        INT:a
           {:  
	      RESULT = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.primitives.ESJInteger"));
	   :}
     |  name:a
           {:  
	       //RESULT = parser.nf.CanonicalTypeNode(null, parser.ts.typeForName(a.toString()));
	     RESULT = parser.nf.AmbTypeNode(null, a.toString());
	   :}
	   ;

quant_kind ::=
        ALL {: RESULT = FormulaBinary.ALL; :}
     |  SOME {: RESULT = FormulaBinary.SOME; :}
     |  NO {: RESULT = FormulaBinary.NO; :}
     |  ONE {: RESULT = FormulaBinary.ONE; :}
     |  LONE {: RESULT = FormulaBinary.LONE; :}
	;

predicate_expr ::=
	or_predicate_expr:a
	    {: RESULT = a; :}   
    ;

or_predicate_expr ::=
	and_predicate_expr:a orPredExpr_opt:b
	    {: if (b == null)
		  RESULT = a;
	       else
		  RESULT = parser.nf.FormulaBinary(parser.pos(a), a,
		                            Binary.COND_OR, b); :}
    ;

orPredExpr_opt ::=
    	    {: RESULT = null; :}
    |
        OROR or_predicate_expr:a
	    {: RESULT = a; :}
    ;    

and_predicate_expr ::=
	equality_predicate_expr:a andPredExpr_opt:b
	    {: if (b == null)
		  RESULT = a;
	       else
		  RESULT = parser.nf.FormulaBinary(parser.pos(a), a,
				            Binary.COND_AND, b); :}
    ;

andPredExpr_opt ::=
    	    {: RESULT = null; :}
    |
        ANDAND and_predicate_expr:a
	    {: RESULT = a; :}
    ;    


equality_predicate_expr ::=
        quantify_expression:a
	    {: RESULT = a; :}
    |
	relational_predicate_expr:a
            {: RESULT = a; :}
    |   relational_predicate_expr:a  equality_predicate_op:b
        equality_predicate_expr:c
	    {: RESULT = parser.nf.CmpBinary(parser.pos(a), a, b, c); :} 
    ;

equality_predicate_op ::=
        EQEQ {: RESULT = Binary.EQ; :}
   |    NOTEQ {: RESULT = Binary.NE; :}
   ;


relational_predicate_expr ::=
	additive_predicate_expr:a
            {: RESULT = a; :}
    |   additive_predicate_expr:a  relational_predicate_op:b
        relational_predicate_expr:c
	    {: RESULT = parser.nf.CmpBinary(parser.pos(a), a, b, c); :}
    ;

relational_predicate_op ::=
       LT {: RESULT = Binary.LT; :}
   |   LTEQ {: RESULT = Binary.LE; :}
   |   GT {: RESULT = Binary.GT; :}
   |   GTEQ {: RESULT = Binary.GE; :}
   ;
    
additive_predicate_expr ::=
        multiplicative_predicate_expr:a
	   {: RESULT = a; :}
   |    multiplicative_predicate_expr:a additive_predicate_op:b
        additive_predicate_expr:c
	   {: RESULT = parser.nf.Binary(parser.pos(a), a, b, c); :}
   ;

additive_predicate_op ::=
        PLUS {: RESULT = Binary.ADD; :}
   |    MINUS {: RESULT = Binary.SUB; :}
   ;
   
multiplicative_predicate_expr ::=
        unary_predicate_expr:a
	   {: RESULT = a; :}
   |    unary_predicate_expr:a MULT multiplicative_predicate_expr:b
	   {: RESULT = parser.nf.Binary(parser.pos(a), a,
	                                Binary.MUL, b); :}
   ;

unary_predicate_expr ::=
	atomic_predicate_expr:a 
	    {: RESULT = a; :}
    |
        MINUS unary_predicate_expr:a
	    {: RESULT = parser.nf.Unary(parser.pos(a), Unary.NEG, a); :}
    |
        NOT unary_predicate_expr:a
	    {: RESULT = parser.nf.Unary(parser.pos(a), Unary.NOT, a); :}
    ;

atomic_predicate_expr ::=
        predicate_literal:a
	    {: RESULT = a; :}	   
    |   formal_or_field_access:a
	    {: RESULT = a; :}	       
    |   LPAREN predicate_expr:a RPAREN
	    {: RESULT = a; :}
    ;

formal_or_field_access ::=
	simple_name:a
	   {: RESULT = a.toExpr(); :}
    |   THIS:a
           {: RESULT = parser.nf.This(parser.pos(a)); :}
    |   IDENTIFIER:a LPAREN argument_list_opt:b RPAREN:c
           {: RESULT = parser.nf.Call(parser.pos(a, c), a.getIdentifier(),
                                      b); :}
    |   field_prefix:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
           {: RESULT = parser.nf.Call(parser.pos(b,d), a, b.getIdentifier(),
                                      c); :}
    |   field_prefix:a DOT IDENTIFIER:b
           {: RESULT = parser.nf.Field(parser.pos(b), a,
				       b.getIdentifier()); :}
    |   formal_or_field_access:a LBRACK predicate_expr:b RBRACK:c
           {: RESULT = parser.nf.ArrayAccess(parser.pos(a, c), a, b); :}
    ;

field_prefix ::=			
    |   THIS:a
           {: RESULT = parser.nf.This(parser.pos(a)); :}
//    |   SUPER:a
//	   {: RESULT = parser.nf.Super(parser.pos(a)); :}
    |	simple_name:a
	   {: RESULT = a.toReceiver(); :}
    |   field_prefix:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
           {: RESULT = parser.nf.Call(parser.pos(b,d), a, b.getIdentifier(),
                                      c); :}
    |   field_prefix:a DOT IDENTIFIER:b
           {: RESULT = parser.nf.Field(parser.pos(b), a,
				       b.getIdentifier()); :}
    |   field_prefix:a DOT XOR IDENTIFIER:b    	   
           {: RESULT = parser.nf.ESJFieldClosure(null, a,
				       b.getIdentifier(), true); :}
    |   formal_or_field_access:a LBRACK predicate_expr:b RBRACK:c
           {: RESULT = parser.nf.ArrayAccess(parser.pos(a, c), a, b); :}
    ;

// currently only allowing ints, booleans, and null   
predicate_literal ::=
        INTEGER_LITERAL:a    
            {: RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); :} 
    |   BOOLEAN_LITERAL:a
            {: RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue()); :}
    |   NULL_LITERAL:a
            {: RESULT = parser.nf.NullLit(parser.pos(a)); :}
    ;


// PART2:  method esnures clause

ensured_method_declaration ::=
        ENSURED ensured_method_header:a method_body:b 
	   {: ESJEnsuredMethodDecl mainMtdDecl = (ESJEnsuredMethodDecl) a.body(b);
              List l = new TypedList(new LinkedList(), ClassMember.class, false);
              l.add(mainMtdDecl);
	      l.add(parser.makeFallbackMtd(mainMtdDecl));
              RESULT = l; 
	   :}
	   ;

ensured_method_header ::=
    modifiers_or_annotations_opt:a type:b method_declarator:c throws_opt:d ensures_opt:z {:
       RESULT = parser.makeESJEnsuredMethodDecl(c.position(), a, parser.array(b, c.dims().intValue()), c.name(), c.formals(), d, null, new TypedList(new LinkedList(), TypeNode.class, false), z); 
        :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c type:d method_declarator:e throws_opt:f ensures_opt:z {:
                                                                                                        RESULT = parser.makeESJEnsuredMethodDecl(e.position(), a, parser.array(d, e.dims().intValue()), e.name(), e.formals(), f, null, c, z); 
                                                                                                        :}
 |  modifiers_or_annotations_opt:a VOID:b method_declarator:c throws_opt:e ensures_opt:z {:
                                                                           RESULT = parser.makeESJEnsuredMethodDecl(c.position(), a, parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), c.name(), c.formals(), e, null, new TypedList(new LinkedList(), TypeNode.class, false), z); 
                                                                           :}
 |  modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c VOID:d method_declarator:e throws_opt:f ensures_opt:z {:
                                                                                                        RESULT = parser.makeESJEnsuredMethodDecl(e.position(), a, parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), e.name(), e.formals(), f, null, c, z); 
                                                                                                        :};

ensures_opt ::=
           {: RESULT = null;  :}
     |  ensures_clause:a 
           {:  RESULT = a;  :}
	   ;

ensures_clause ::=
        ENSURES predicate_expr:a
           {: RESULT = a; :}
	   ;

// PART3:      ESJClassInvariantDecl

override type_declaration ::=
    ensured_class_declaration:a {:  RESULT = a;  :}
 |  interface_declaration:a {:  RESULT = a;  :}
 |  SEMICOLON {:  RESULT = null;  :}
 |  enum_declaration:a {:  RESULT = a;  :};

ensured_class_declaration ::=
    modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c {: parser.currClassName(c.getIdentifier()); :} type_parameters_opt:d super_opt:e interfaces_opt:f ensures_opt:z LBRACE class_body_declarations_opt:y RBRACE
           {: List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	      extraMtdBody.add(parser.nf.Return(null,z == null ? parser.nf.BooleanLit(null, true) : z));
	      JL5MethodDecl invariantMtdDecl = parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(), parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.Boolean()), 0), "verifyInvariants", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, extraMtdBody), new TypedList(new LinkedList(), TypeNode.class, false));
	      TypedList l = new TypedList(new LinkedList(), ClassMember.class, false);
	      List classFieldNs = new TypedList(new LinkedList(), String.class, false);
	      if (!parser.currClassName.equals("MyList")) { // HACK FIXME
 	      	 // define a static list to keep instance list

	      	 List gt = new TypedList(new LinkedList(), TypeNode.class, false);
	      	 AmbTypeNode cl = parser.nf.AmbTypeNode(null, c.getIdentifier());
	      	 gt.add(cl);
	      	 AmbTypeNode tn = parser.nf.AmbTypeNode(null, "polyglot.ext.esj.primitives.ESJList");
	      	 AmbTypeNode atn = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), gt);
     	      	 List<Flags> fs = new ArrayList<Flags>();
	      	 fs.add(Flags.STATIC);
              	 l.add(parser.nf.JL5FieldDecl(null,parser.makeFlagAnnotations(fs), parser.array(atn, 0),"allInstances", parser.nf.JL5New(null, atn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
     	      	 List<Flags> fs2 = new ArrayList<Flags>();
	      	 fs2.add(Flags.STATIC);
	      	 fs2.add(Flags.PUBLIC);
	      	 l.add(parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(fs2), parser.array(atn, 0), "allInstances", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, cl, "allInstances"))), new TypedList(new LinkedList(), TypeNode.class, false)));
	      	 List args2 = new TypedList(new LinkedList(), Expr.class, false);	   
	      	 args2.add(parser.nf.ClassLit(null, cl));
	      	 l.add(parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(fs2), parser.array( parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogSet")), 0), "allInstances_log", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "bounds_log", args2))), new TypedList(new LinkedList(), TypeNode.class, false)));

	      	 // define relationize() and setPrime()...
	      	 List args = new TypedList(new LinkedList(), Expr.class, false);
	      	 args.add(parser.nf.This(null));
	      	 JL5MethodDecl relationizeMtdDecl = parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(), parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.Void()), 0), "relationize", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, parser.nf.Eval(null, parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newAtom", args))), new TypedList(new LinkedList(), TypeNode.class, false));
	      	 l.add(relationizeMtdDecl);
	      	 List setPrimeMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
	      	 for (Node n : (List<Node>) y) {
		     if (n instanceof ESJFieldDecl) {
		        ESJFieldDecl fi = (ESJFieldDecl) n;
		     	if (!fi.isPrime()) {
			    classFieldNs.add(fi.name());
			    setPrimeMtdBody.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Field(null, parser.nf.This(null), fi.name()+"_prime"), Assign.ASSIGN, parser.nf.Field(null, parser.nf.This(null), fi.name()))));
		  	    List instVarGetArgs2 = new TypedList(new LinkedList(), Expr.class, false);
		  	    List instVarGetArgs3 = new TypedList(new LinkedList(), Expr.class, false);
		  	    instVarGetArgs2.add(parser.nf.This(null));
		  	    instVarGetArgs2.add(parser.nf.StringLit(null, fi.name()+"_prime"));
		  	    instVarGetArgs3.add(parser.nf.This(null));
		  	    instVarGetArgs3.add(parser.nf.Field(null, parser.nf.This(null), fi.name()));
			    Expr e1 = parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "instVarRel_log", instVarGetArgs2);
			    Expr e2 = parser.nf.Call(null, e1, "put_log", instVarGetArgs3);
			    setPrimeMtdBody.add(parser.nf.Eval(null, e2));
			}
	             }			    
	       	 }
	      	 JL5MethodDecl setPrimeMtdDecl = parser.nf.JL5MethodDecl(null, parser.makeFlagAnnotations(), parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.Void()), 0), "setPrime", new TypedList(new LinkedList(), Expr.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null, setPrimeMtdBody), new TypedList(new LinkedList(), TypeNode.class, false));
	     	 l.add(setPrimeMtdDecl);
	      }
	      l.add(invariantMtdDecl);
	      l.addAll(parser.defineESJExtraMethods(invariantMtdDecl));	
	      l.addAll(y);
	      RESULT = parser.nf.ESJEnsuredClassDecl(null, a, c.getIdentifier(), e, f, parser.nf.JL5ClassBody(null, l), d, classFieldNs); 
           :}
	   ;

// PART4:	Relationizing instance variables

override field_declaration ::=
    modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e 
           {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
       	      for (Iterator i = c.iterator(); i.hasNext(); ) {
              	  VarDeclarator d = (VarDeclarator) i.next();
		  if (a.classicFlags().isStatic()) {		  
         	     l.add(parser.nf.JL5FieldDecl(parser.pos(b, e),a, parser.array(b, d.dims),d.name, d.init));
		  } else {
         	     l.add(parser.nf.ESJFieldDecl(parser.pos(b, e),a, parser.array(b, d.dims),d.name, d.init, false));

	 	     System.out.println("somebody adding a fieeeeeld!" + d.name);
		     List args = new TypedList(new LinkedList(), Expr.class, false);
		     List relDefBodyArgs = new TypedList(new LinkedList(), Expr.class, false);

		     relDefBodyArgs.add(parser.nf.StringLit(null,parser.currClassName));
		     relDefBodyArgs.add(parser.nf.StringLit(null,d.name));
		     relDefBodyArgs.add(parser.nf.StringLit(null,parser.currClassName));	
		     relDefBodyArgs.add(parser.nf.ClassLit(null, b));
		     relDefBodyArgs.add(parser.nf.BooleanLit(null, true));
		     Block relDefBody = parser.nf.Block(null, parser.nf.Eval(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newInstVarRel", relDefBodyArgs)));
                     l.add(parser.nf.Initializer(null, Flags.STATIC, relDefBody));

	             args.add(parser.nf.StringLit(null, d.name));
		     List instVarGetArgs = new TypedList(new LinkedList(), Expr.class, false);
		     instVarGetArgs.add(parser.nf.This(null));
		     instVarGetArgs.add(parser.nf.StringLit(null, d.name));
		     l.add(parser.nf.JL5MethodDecl(null, a, parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogAtom")), 0), d.name+"_log", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "instVar_log", instVarGetArgs))), new TypedList(new LinkedList(), TypeNode.class, false)));
		     // also define a prime (pre state value) for inst var:
		     l.add(parser.nf.ESJFieldDecl(parser.pos(b, e),a, parser.array(b, d.dims),d.name+"_prime", d.init, true));
     	      	     List<Flags> fs = new ArrayList<Flags>();
	      	     fs.add(Flags.PUBLIC);
		     FlagAnnotations fl = parser.makeFlagAnnotations(fs);
		     l.add(parser.nf.JL5MethodDecl(null, fl, parser.array(b, d.dims), d.name+"_prime", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Field(null, parser.nf.This(null), d.name+"_prime"))), new TypedList(new LinkedList(), TypeNode.class, false)));
		     TypedList instVarGetArgsP = TypedList.copy(instVarGetArgs, Expr.class, false);
		     instVarGetArgsP.set(1,parser.nf.StringLit(null, d.name+"_prime"));
		     l.add(parser.nf.JL5MethodDecl(null, a, parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogAtom")), 0), d.name+"_prime_log", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "instVar_log", instVarGetArgsP))), new TypedList(new LinkedList(), TypeNode.class, false)));
		     TypedList relDefBodyArgsP = TypedList.copy(relDefBodyArgs, Expr.class, false);
		     relDefBodyArgsP.set(4,parser.nf.BooleanLit(null, false));
		     Block relDefBodyP = parser.nf.Block(null, parser.nf.Eval(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "newInstVarRel", relDefBodyArgsP)));
                     l.add(parser.nf.Initializer(null, Flags.STATIC, relDefBodyP));
		     // also define field closure access for recursive fields
		     if (b.toString().equals(parser.currClassName+"{amb}")) { //FIXME
	      		List gt = new TypedList(new LinkedList(), TypeNode.class, false);
	      		AmbTypeNode cl = parser.nf.AmbTypeNode(null, parser.currClassName);
	      		gt.add(cl);
	      		AmbTypeNode tn = parser.nf.AmbTypeNode(null, "java.util.ArrayList");
	      		AmbTypeNode atn = parser.nf.JL5AmbTypeNode(null, ((AmbTypeNode)tn).qual(), ((AmbTypeNode)tn).name(), gt);

		     	List extraMtdBody = new TypedList(new LinkedList(), Stmt.class, false);
			List whileLoopStmts = new TypedList(new LinkedList(), Stmt.class, false);
			whileLoopStmts.add(parser.nf.Eval(null, parser.nf.Assign(null, parser.nf.Local(null, "curr"), Assign.ASSIGN, parser.nf.Field(null, parser.nf.Local(null, "curr"), d.name))));
		     	List argsW = new TypedList(new LinkedList(), Expr.class, false);
			argsW.add(parser.nf.Local(null, "curr"));
			whileLoopStmts.add(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.Local(null, "res"), "add", argsW)));
			Stmt whileLoopBody = parser.nf.Block(null, whileLoopStmts);
		 	extraMtdBody.add(parser.nf.JL5LocalDecl(null, parser.makeFlagAnnotations(), atn, "res", parser.nf.JL5New(null, atn, new TypedList(new LinkedList(), Expr.class, false), null, new TypedList(new LinkedList(), TypeNode.class, false))));
		 	extraMtdBody.add(parser.nf.JL5LocalDecl(null, parser.makeFlagAnnotations(), cl, "curr", parser.nf.This(null)));
			extraMtdBody.add(parser.nf.While(null, parser.nf.Binary(null, parser.nf.Field(null, parser.nf.Local(null, "curr"), d.name), Binary.NE, parser.nf.NullLit(null)), whileLoopBody));
			extraMtdBody.add(parser.nf.JL5Return(null, parser.nf.Local(null,"res")));
			Block extraMtdBlock = parser.nf.Block(null, extraMtdBody);


		     	l.add(parser.nf.JL5MethodDecl(null, a, parser.array(atn, 0), d.name+"_closure", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), extraMtdBlock, new TypedList(new LinkedList(), TypeNode.class, false)));

		     	List instVarGetArgsC = new TypedList(new LinkedList(), Expr.class, false);
		     	instVarGetArgsC.add(parser.nf.This(null));
		     	instVarGetArgsC.add(parser.nf.StringLit(null, d.name));

		     	l.add(parser.nf.JL5MethodDecl(null, a, parser.array(parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogSet")), 0), d.name+"_closure_log", new TypedList(new LinkedList(), Formal.class, false), new TypedList(new LinkedList(), TypeNode.class, false), parser.nf.Block(null,parser.nf.JL5Return(null,parser.nf.Call(null, parser.nf.CanonicalTypeNode(null, parser.ts.typeForName("polyglot.ext.esj.tologic.LogMap")), "instVarClosure_log", instVarGetArgsC))), new TypedList(new LinkedList(), TypeNode.class, false)));

		     }
		  }
              }
              RESULT = l; 
           :}
	   ;

override constructor_declaration ::=
    modifiers_or_annotations_opt:a constructor_declarator:b throws_opt:c constructor_body:d 
           {:
              List args = new TypedList(new LinkedList(), Expr.class, false);
	      args.add(parser.nf.This(null));
              RESULT = parser.nf.JL5ConstructorDecl(b.position(), a, b.name(), b.formals(), c, d.append(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.Field(null, parser.nf.This(null), "allInstances"), "add", args)))/*.append(parser.nf.Eval(null, parser.nf.Call(null, null, "relationize", new TypedList(new LinkedList(), Expr.class, false))))*/, new TypedList(new LinkedList(), TypeNode.class, false)); 
	   :}
 | modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c constructor_declarator:d throws_opt:e constructor_body:f 
           {: List args = new TypedList(new LinkedList(), Expr.class, false);
	      args.add(parser.nf.This(null));
              RESULT = parser.nf.JL5ConstructorDecl(d.position(), a, d.name(), d.formals(), e, f.append(parser.nf.Eval(null, parser.nf.Call(null, parser.nf.Field(null, parser.nf.This(null), "allInstances"), "add", args))), c); 

           :}
	   ;
