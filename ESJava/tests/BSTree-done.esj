import polyglot.ext.esj.primitives.*;
import polyglot.ext.esj.tologic.*;


class Node
{
    public Integer key;
    public Integer value;
    public Node left;
    public Node right;
    public Node parent;

    public Node(Integer key, Integer value, Node left, Node right) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        if (left != null) left.parent = this;
        if (right != null) right.parent = this;
        this.parent = null;
    }

    public Node left() { return left; }
    public Node left(Node l) { this.left = l; return this; }

    function public HashSet<Node> children() {
	this.^(left+right)
    }

    public String toString() {
	return "Node(" + key + "," + value + ")";
    }

}

public class BSTree
    // CLASS IVARIANTS
    ensures isBinarySearchTree() {

    public Node root;
    
    // FUNCTION METHODS    
    function public Set nodes() {
	root.*(left+right)
    }

    function public boolean isBinarySearchTree() {
	isAcyclic() && oneParent() && valuesValid()
    }

    function public boolean isAcyclic() {
	no Node n : nodes() | n.^(left+right).contains(n)
    }

    function public boolean oneParent() {
	all Node n : nodes() | lone Node p | p.left == n
    }

    function public boolean valuesValid() {
	all Node n : nodes() | (all c: n.left.*(left+right) | c.value < n.value &&
				all c: n.right.*(left+right) | c.value > n.value)
    }

    ensured public void insert(Node node) 
	ensures (nodes().equals(nodes().prime().union(node))) {
	// body...?
    }    

    ensured public void delete(Node node) 
	ensures (nodes().equals(nodes().prime().minus(node))) {
	// body...?
    }

    public void insert(Integer key, Integer value) {
	insert(new Node(key, value, null, null));
    }
    
    public void delete(Integer key) {
	delete(lookupNode(key));
    }

    private Node lookupNode(Integer key) {
        Node n = root;
        while (n != null) {
            int compResult = key.compareTo(n.key);
            if (compResult == 0) {
                return n;
            } else if (compResult < 0) {
                n = n.left;
            } else {
                assert compResult > 0;
                n = n.right;
            }
        }
        return n;
    }

    public static void main(String[] args) {
	int MAX_SIZE = 1;
	Random rand = new Random(1111L);

        BSTree t = new BSTree();
        t.print();

	// create an array of the given size
	int[] a = new int[MAX_SIZE];
	  	
	for (int i = 0 ; i < MAX_SIZE; ++i) {
	    a[i] = i;// * 5;
	}

	// randomly shuffle the elements in the array and 
	// insert them in the tree	
	for (int i = MAX_SIZE; i>0; --i) {
	    int n = rand.nextInt(i);
	    int temp = a[n];
	    a[n] = a[i-1];
	    t.insert(temp,temp);
	    t.print();
	    }

    }

}

