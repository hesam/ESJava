/* 
 * Copyright (c) 2002, Cameron Zemek
 * 
 * This file is part of JSpread.
 * 
 * JSpread is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * JSpread is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.capsicumcorp.swing.spreadsheet;

import java.util.*;
import net.sf.jeppers.expression.*;
import net.sf.jeppers.expression.function.*;
import net.sf.jeppers.grid.*;

//HS
import polyglot.ext.esj.primitives.*;
import polyglot.ext.esj.tologic.*;

/**
 * Workbook is responsible for updating formulas.
 * 
 * @version 1.0
 * 
 * @author  <a href="mailto:grom@capsicumcorp.com">Cameron Zemek</a>
 */
public class Workbook implements GridModelListener {
    // Map of cell to collection of referencing cells 
	protected Map referenceMap = new HashMap();
	
	// Map of references to formula and formula object
	protected Map formulaMap = new HashMap();
	
	// Map of worksheet names to GridModel
	protected Map worksheets = new HashMap();
	
	// Parsers expressions
	protected ExpressionCompiler compiler;
	
        // HS
    protected ESJMap<CellReference,Integer> cellValueMap = new ESJMap<CellReference,Integer>();
    protected ESJMap<CellReference,Expression> cellExprMap = new ESJMap<CellReference,Expression>();
    spec protected ESJSet<CellReference> cells = new ESJSet<CellReference>(); //HS
    protected CellReference lastCell; //HS
	// Set of dirty cells
	private transient Set dirtyCells;
    
    // Set of cells we have visted. Used to detect circular references
    private transient Set visitCells = new HashSet();


    public ESJMap<CellReference,Integer> cellValueMap() { return this.cellValueMap; } //HS
    
    // Don't listen to grid changes when true
	protected boolean block = false;

	/** Creates a new instance of Workbook */
	public Workbook() {
		compiler = new ExpressionCompiler();
		compiler.setFunction("if", new If());
	}

	/**
	 *  Add tableModel to worbook
	 */
	public void addWorksheet(String sheetName, GridModel gridModel) {
		gridModel.addGridModelListener(this);
		worksheets.put(sheetName, gridModel);
	} //end addWorksheet

	/**
	 *  Remove tableModel from workbook
	 */
	public void removeWorksheet(String sheetName) {
		GridModel gridModel = (GridModel) worksheets.get(sheetName);
		gridModel.removeGridModelListener(this);
		worksheets.remove(sheetName);
	} //end removeWorksheeet        
	
	private void markReferencesAsDirty(CellReference ref) throws CircularReferenceException {
		Collection refCells = (Collection) referenceMap.get(ref);
		if (refCells == null) {
			return;
		}
        if (visitCells.contains(ref)) {
            throw new CircularReferenceException();
        } else {
            visitCells.add(ref);
        }
		Iterator it = refCells.iterator();
		while (it.hasNext()) {
			FormulaInfo formula = (FormulaInfo) it.next();
			CellReference formulaRef = formula.getReference();
			if (! dirtyCells.contains(formulaRef)) {
				dirtyCells.add(formulaRef);			
				markReferencesAsDirty(formulaRef);
			}
		}        
	}

	private HashSet affectedCells(CellReference ref) {
	    HashSet r = new HashSet();
	    Collection refCells = (Collection) referenceMap.get(ref);
	    if (refCells == null)
		return r;
	    Iterator it = refCells.iterator();
	    while (it.hasNext()) {
		FormulaInfo formula = (FormulaInfo) it.next();
		CellReference formulaRef = formula.getReference();
		r.add(formulaRef);
		r.addAll(affectedCells(formulaRef));
	    }
	    return r;
	}
    
    private void error(CellReference ref) {
        block = true;
        dirtyCells.clear();
        markError(ref);
        block = false;
    }
    
    private void markError(CellReference ref) {
        Collection refCells = (Collection) referenceMap.get(ref);
        if (refCells == null) {
            return;
        }
        Iterator it = refCells.iterator();
        while (it.hasNext()) {
            FormulaInfo formula = (FormulaInfo) it.next();
            CellReference formulaRef = formula.getReference();
            if (! dirtyCells.contains(formulaRef)) {
                dirtyCells.add(formulaRef);                
                Expression error = new Expression(ref, formula.formulaExpression.getExpression(), new Token[0], null, null, null, null, null) {
                    public Integer getCachedResult() {
                        return -1;
                    }
                };
                formulaRef.model.setValueAt(error, formulaRef.row, formulaRef.column);
                markError(formulaRef);
            }
        }         
    }

    private HashSet<CellReference> modifiables() {
	HashSet<CellReference> r = new HashSet<CellReference>(cellExprMap.keySet());
	if (lastCell != null)
	    r.add(lastCell);
	return r;
    }

    public boolean toLogic() { return false; }

    public LogFormula toLogic_log() {
	LogFormula f = new LogFormula("true");
	for (CellReference ck : cellExprMap.keySet()) {
	    System.out.print(ck + " log: ");
	    System.out.println(cellExprMap.get(ck).toLogic_log());
	    f = f.formulaOp("&&", cellExprMap.get(ck).toLogic_log());
	} 
	return f;
    }


    public void gridChanged(GridModelEvent evt) {
	if (block) {
	    /* Ignore change if it was caused by formula.update() */
	    return;
	}
        GridModel source = (GridModel) evt.getSource();
        int firstRow = evt.getFirstRow();
        int lastRow = evt.getLastRow();
        int firstColumn = evt.getFirstColumn();
        int lastColumn = evt.getLastColumn();
        for (int row = firstRow; row <= lastRow; row++) {
            for (int column = firstColumn; column <= lastColumn; column++) {
                Object value = source.getValueAt(row, column);
                CellReference ck = null;
		if (source.getCellAt(row,column) == null) {
		    ck = new CellReference(row, column, source);
		    cells.add(ck);
		    source.setCellAt(ck,row,column);
		} else {
		    ck = source.getCellAt(row,column);		    
		}		
	    }
	}
	gridChangedH(evt);
    }


	/**
	 *  Listens to worksheets for changes
	 */
	public void gridChangedH(GridModelEvent evt) 
	    modifies fields CellReference.cachedResult //Workbook.cellValueMap
	    modifies objects modifiables()
	    ensures toLogic() { 
	    if (block) {
		/* Ignore change if it was caused by formula.update() */
		return;
	    }
        GridModel source = (GridModel) evt.getSource();
        int firstRow = evt.getFirstRow();
        int lastRow = evt.getLastRow();
        int firstColumn = evt.getFirstColumn();
        int lastColumn = evt.getLastColumn();
        for (int row = firstRow; row <= lastRow; row++) {
            for (int column = firstColumn; column <= lastColumn; column++) {
                Object value = source.getValueAt(row, column);
                CellReference ck = null;
		ck = source.getCellAt(row,column);		    
		lastCell = null; //HS
                // Delete existing formula
                FormulaInfo formula = (FormulaInfo) formulaMap.get(ck);
                if (formula != null) {                  
                    formula.delete();
                }
                
                // Add new formula              
                if (value != null && value.toString().startsWith("=")) { 
		    lastCell = ck;   //HS
                    // Convert formula into expression
                    Expression exp =
                        compiler.compile(ck, value.toString().substring(1), this);

                    formula = new FormulaInfo(ck, exp);
                    formulaMap.put(ck, formula);
                    formula.update();
                } //end if

		//HS
		Object val = source.getValueAt(row,column);
		if (val instanceof String) {
		    Integer v = Integer.parseInt((String) val);
		    cellValueMap.put(ck,v);
		    ck.cachedResult(v); //HS
		} else {
		    cellExprMap.put(ck,(Expression) val);

		}
		System.out.println("firstRow= " + firstRow + " lastRow= " + lastRow + " firstColumn= " + firstColumn + " lastColumn= " + lastColumn + "\nreferenceMap: " + referenceMap + "\nformulaMap: " + formulaMap + "\nworksheets: " + worksheets  + "\ndirtyCells: " + dirtyCells + "\nvisitCells: " + visitCells + " cellValueMap: " + cellValueMap + " cellExprMap: " + cellExprMap + " cells: " + cells);
	
		int z = 1/0;
		//HS END

                
                // Update cells which reference the changed cell                
                // 1. Mark the cells as dirty                
                dirtyCells = new HashSet();
                try {
                    markReferencesAsDirty(ck);
		    System.out.println("need update: " + affectedCells(ck));
                } catch (CircularReferenceException e) {                    
                    block = true;
                    Expression error = new Expression(ck, value.toString().substring(1), new Token[0], null, null, null, null, null) {
                        public Integer getCachedResult() {
                            return -1;
                        }
                    };
                    source.setValueAt(error, row, column);
                    
                    // Propagate error to the cells that reference this one
                    error(ck);
                    
                    block = false;
                    continue;
                }
                // 2. Update the dirty cells
                while(dirtyCells.size() > 0) {                  
                    Iterator it = dirtyCells.iterator();
                    CellReference ref = (CellReference) it.next();
                    formula = (FormulaInfo) formulaMap.get(ref);
                    formula.update();
                }
            } //end for(column)
        } //end for(row)
        visitCells.clear();

        dirtyCells = null;  


	} //end gridChanged

	public void updateAll() {
		// Initialise formulas
		Iterator it = formulaMap.values().iterator();
		while (it.hasNext()) {
			FormulaInfo formula = (FormulaInfo) it.next();
			formula.update();
		}
	}
	

	/**
	 *  FormulaInfo information
	 */
	protected class FormulaInfo {
		protected CellReference cellRef;
		protected Expression formulaExpression;
		// Map of variable names to cell references
		protected Map varRefMap = new HashMap();
	    
	    protected List<FormulaInfo> allInstances = new ArrayList<FormulaInfo>(); //HS

		public FormulaInfo(
			CellReference cellReference,
			Expression exp) {
			this.cellRef = cellReference;
			this.formulaExpression = exp;

			// build cell reference table
			Iterator i = exp.getReferences().iterator();
			while (i.hasNext()) {
				Object variableKey = i.next();
				String variableName = variableKey.toString();

				GridModel refModel = null;
				int index = 0; //parse position

				// Parse sheet name
				int endSheetNameIndex = variableName.indexOf("!");
				if (endSheetNameIndex == -1) { //no sheet name
					refModel = cellRef.model;
				} else {
					String sheetName =
						variableName.substring(0, endSheetNameIndex).toUpperCase();
					refModel = (GridModel) worksheets.get(sheetName);
				} //end if				
				index = endSheetNameIndex + 1; //consume '!' character

				// Parse column
				char colChar = 'A';
				StringBuffer colBuff = new StringBuffer(variableName.length());
				do {
					colChar = variableName.charAt(index);
					if (Character.isLetter(colChar)) {
						colBuff.append(colChar);
						index++;
					} //end if                    
				} while (Character.isLetter(colChar));

				String colName = colBuff.toString();
				int lastPos = colName.length() - 1; // last index position in colName
				int column = -1; // we subtract 1 from final result
				for (int strIndex = lastPos;
					strIndex >= 0;
					strIndex--) {
					column += ((colName.charAt(strIndex) - 'A') + 1)
						* (int) Math.pow(26, lastPos - strIndex);
				}

				int row = Integer.parseInt(variableName.substring(index));
				
				CellReference reference = refModel.getCellAt(row,column); //new CellReference(row, column, refModel); //HS
				varRefMap.put(variableName, reference);
				
				// Listen to changes on the reference cell
				Collection refCells = (Collection) referenceMap.get(reference);
				if (refCells == null) {
					refCells = new HashSet();
					referenceMap.put(reference, refCells);
				}
				refCells.add(this);
			} //end while
		} //end constructor
		
		public void delete() {
			// Stop listening to changes on the reference cells
			Iterator it = varRefMap.values().iterator();
			while (it.hasNext()) {
				CellReference ref = (CellReference) it.next();
				Collection refCells = (Collection) referenceMap.get(ref);
				refCells.remove(this);								
			}
			formulaMap.remove(this);
		}

		public CellReference getReference() {
			return cellRef;
		}

		/**
		 *  Update the formula
		 */
		public void update() {			
			// Update variable values
			Iterator i = formulaExpression.getReferences().iterator();
			while (i.hasNext()) {
				Object variableKey = i.next();
				String variableName = variableKey.toString();

				CellReference reference = (CellReference) varRefMap.get(variableName);
				int row = reference.row;
				int column = reference.column;
				GridModel model = (GridModel) reference.model;
				
				// If reference cell needs updating
				if (dirtyCells != null && dirtyCells.contains(reference)) {
					FormulaInfo formula = (FormulaInfo) formulaMap.get(reference);
					formula.update();
				}

				Object variableValue = model.getValueAt(row, column);
				if (variableValue instanceof Expression) {
				    variableValue = (Object) ((Expression) variableValue).evaluate();
				}

				if (variableValue == null) {
					variableValue = "";
				}
				//compiler.setVariable(variableName, variableValue);
				compiler.setVariable(reference, variableValue instanceof String ? Integer.parseInt((String) variableValue) : (Integer) variableValue); //HS
				compiler.setVarRef(variableName, reference); //HS
			} //end while			
			
			block = true;
			formulaExpression.evaluate();
			cellRef.model.setCellAt(cellRef,cellRef.row,cellRef.column);
			cellRef.model.setValueAt(
				formulaExpression,
				cellRef.row,
				cellRef.column);
			block = false;
			
			if (dirtyCells != null) {
				dirtyCells.remove(cellRef);
			}
		} //end update
	} //end inner class FormulaInfo
} //end Workbook
