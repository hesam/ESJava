import polyglot.ext.esj.primitives.*;
import polyglot.ext.esj.tologic.*;

import java.util.HashSet;
import java.util.Random;

public class BSTree 
    ensures isBinarySearchTree()
{

    private static final int INDENT_STEP = 4;

    spec public Node root;

    public BSTree() { root = null; }

    public void root(Node r) { this.root = r; }

    function public ESJSet<Node> nodes() { root.*(left+right) }

    function public ESJSet<Integer> nodeValues() { this.nodes().<value }

    function public boolean isBinarySearchTree() {
	isAcyclic() && parentDef() && oneParent() && isValidBinarySearch() 
    }

    function public boolean isAcyclic() { 
	no Node n | (n.descendants().contains(n) || n.ancestors().contains(n)) 
    }

    function public boolean parentDef() {
	all Node n | all Node p | (!p.children().contains(n) || n.parent == p)
    }

    function public boolean oneParent() {
	(root == null) ? true : all Node n : this.root.descendants() | one Node p | n.parent == p
    }

    function public boolean isValidBinarySearch() {
       all Node n | ((n.left == null  || all Node lc : n.leftDescendants()  | lc.value < n.value) &&
        	     (n.right == null || all Node rc : n.rightDescendants() | rc.value > n.value))
    }

    public void insert(Integer value) {
        Node insertedNode = new Node(value, null, null);
	insert(insertedNode);
    }

    public void insert(Node node)
	modifies fields BSTree.root, Node.left, Node.right, Node.parent
	modifies objects getNewNodeParentToBe(node)
	ensures this.nodes().equals(this.old.nodes().plus(node)) {
	// no implementation...
    }    
    
    public void delete(Integer value)
	modifies fields BSTree.root, Node.left, Node.right, Node.parent
	modifies objects getParentAndChildren(value)
	ensures this.nodeValues().equals(this.old.nodeValues().minus(value)) {
	// no implementation...
    }

    public HashSet<Object> getNewNodeParentToBe(Node node) {
	HashSet<Object> res = new HashSet<Object>();
	res.add(node);
	if (root == null) {
	    res.add(this);
	    return res;
	}	    
	Node n = root;
	Integer value = node.value;
	while (true) {
	    int compResult = value.compareTo(n.value);
	    if (compResult == 0) {
		break;
	    } else if (compResult < 0) {
		if (n.left == null) {		   
		    break;
		} else {
		    n = n.left;
		}
	    } else {
		assert compResult > 0;
		if (n.right == null) {		    
		    break;
		} else {
		    n = n.right;
		}
	    }
	}
	res.add(n);
	return res;
    }


    public HashSet<Object> getParentAndChildren(Integer value) {
	HashSet<Object> res = new HashSet<Object>();
	Node node = lookupNode(value);
	res.add(node);	
	if (root == node)
	    res.add(this);
	else
	    res.add(node.parent);
	if (node.left != null)
	    res.add(node.left);
	if (node.right != null)
	    res.add(node.right);
	return res;
    }

    private Node lookupNode(Integer value) {
        Node n = root;
        while (n != null) {
            int compResult = value.compareTo(n.value);
            if (compResult == 0) {
                return n;
            } else if (compResult < 0) {
                n = n.left;
            } else {
                n = n.right;
            }
        }
        return n;
    }

    public void print() {
        printHelper(root, 0);
	System.out.println("---------------------------------------" + 
			   (root == null ? 0 : nodes().size()) + " nodes");
    }

    private static void printHelper(Node n, int indent) {
        if (n == null) {
            System.out.println("<empty tree>");
            return;
        }
        if (n.right != null) {
            printHelper(n.right, indent + INDENT_STEP);
        }
        for (int i = 0; i < indent; i++)
            System.out.print(" "); 
            System.out.println(n.value);
        if (n.left != null) {
            printHelper(n.left, indent + INDENT_STEP);
        }
    }
        
    public static void main(String[] args) {
	//LogMap.SolverOpt_debugLevel(1);
	//ESJInteger.setBounds(0,39);
	int MAX_SIZE = 20;
	boolean testDelete = true;
	Random rand = new Random(1111L);

        BSTree t = new BSTree();
        t.print();

	// create an array of the given size
	int[] a = new int[MAX_SIZE];
	  	
	for (int i = 0 ; i < MAX_SIZE; ++i) {
	    a[i] = i;
	}

	// randomly shuffle the elements in the array and 
	// insert them in the tree	
	// then remove all from top
	for (int i = MAX_SIZE; i>0; --i) {
	    int n = rand.nextInt(i);
	    int temp = a[n];
	    a[n] = a[i-1];
	    t.insert(temp);
	    t.print();
	    }
	if (testDelete) {
	    for (int i = MAX_SIZE - 1; i>=0; --i) {
		t.delete(i);
		t.print();
	    }
	}
	
    }
    
}

