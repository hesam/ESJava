import polyglot.ext.esj.primitives.*;
import polyglot.ext.esj.tologic.*;

import java.util.HashSet;
import java.util.Random;

public class RBTree 
    ensures isRBTree()
{

    private static final int INDENT_STEP = 4;

    spec public Node root;

    public RBTree() { root = null; }

    public void root(Node r) { this.root = r; }

    function public ESJSet<Node> nodes() { root.*(left+right) }

    function public ESJSet<Node> leaves() 
    { { Node n : nodes() | (n.left == null || n.right == null) }  }

    function public ESJSet<Integer> nodeValues() { this.nodes().<value }

    function public boolean isRBTree() {
	isBinarySearchTree() && rootBlack() && redsChildren() && eqBlacks()
    }

    function public boolean isBinarySearchTree() {
	isAcyclic() && parentDef() && oneParent() && isValidBinarySearch() 
    }

    function public boolean rootBlack() { this.root == null || this.root.color == Color.BLACK }

    function public boolean redsChildren() {
	all Node n : nodes() | (n.color == Color.BLACK || 
				all Node c : n.children() | c.color == Color.BLACK)
    }

    function public boolean eqBlacks() {
	all Node l1 : leaves() | 
	    all Node l2: leaves() |
	        (l1 == l2 || l1.blackAncestors().size() == l2.blackAncestors().size())
    }

    function public boolean isAcyclic() { 
	no Node n | (n.descendants().contains(n) || n.ancestors().contains(n)) 
    }

    function public boolean parentDef() {
	all Node n | all Node p | (!p.children().contains(n) || n.parent == p)
    }

    function public boolean oneParent() {
	(root == null) ? true : all Node n : this.root.descendants() | one Node p | n.parent == p
    }

    function public boolean isValidBinarySearch() {
       all Node n | ((n.left == null  || all Node lc : n.leftDescendants()  | lc.value < n.value) &&
        	     (n.right == null || all Node rc : n.rightDescendants() | rc.value > n.value))
    }

    public void insert(Integer value) {
        Node insertedNode = new Node(value, null, null);
	insert(insertedNode);
    }

    public void insert(Node insertedNode)
	modifies fields RBTree.root, Node.color, Node.left, Node.right, Node.parent
    //modifies objects getAffectedNodesOnInsert(insertedNode);
	ensures this.nodes().equals(this.old.nodes().plus(insertedNode)) {
	// no implementation...
    }    

    public void delete(Integer value)
	modifies fields RBTree.root, Node.color, Node.left, Node.right, Node.parent
	ensures this.nodeValues().equals(this.old.nodeValues().minus(value)) {
	// no implementation...
    } 

    private HashSet<Object> getAffectedNodesOnInsert(Node node) {
	HashSet<Object> res = new HashSet<Object>();
	getAffectedNodesOnInsert1(node, res);
	return res;
    }

    private void getAffectedNodesOnInsert1(Node n, HashSet<Object> affectedNodes) {
	System.out.println("case1");
        if (n.parent == null)
            affectedNodes.add(n.value);
        else
            getAffectedNodesOnInsert2(n, affectedNodes);
    }

    private void getAffectedNodesOnInsert2(Node n, HashSet<Object> affectedNodes) {
	System.out.println("case2");
        if (n.parent.color == Color.BLACK) {
	    affectedNodes.add(n.parent.value);
            return; // Tree is still valid
	} else
            getAffectedNodesOnInsert3(n, affectedNodes);
    }

    void getAffectedNodesOnInsert3(Node n, HashSet<Object> affectedNodes) {
        if (n.uncle().color == Color.RED) {
	    System.out.println("case3.1");
	    affectedNodes.add(n.parent.value);
	    affectedNodes.add(n.uncle().value);
	    affectedNodes.add(n.grandparent().value);
            getAffectedNodesOnInsert1(n.grandparent(), affectedNodes);
        } else {
	    System.out.println("case3.2");
            getAffectedNodesOnInsert4(n, affectedNodes);
        }
    }

    void getAffectedNodesOnInsert4(Node n, HashSet<Object> affectedNodes) {
	if (n.parent != null) 
	    affectedNodes.add(n.parent.value);
	if (n.grandparent() != null) 
	    affectedNodes.add(n.grandparent().value);
	if (n.parent.grandparent() != null) 
	    affectedNodes.add(n.parent.grandparent().value);
        if (n == n.parent.right && n.parent == n.grandparent().left) {
	    affectedNodes.add(n.parent.left.value);
	    if (n.left != null) 
		affectedNodes.add(n.left.value);
	    if (n.right != null) 
		affectedNodes.add(n.right.value);
        } else if (n == n.parent.left && n.parent == n.grandparent().right) {
	    affectedNodes.add(n.parent.right.value);
	    if (n.left != null) 
		affectedNodes.add(n.left.value);
	    if (n.right != null) 
		affectedNodes.add(n.right.value);            
        }
    }

    private HashSet<Object> getAffectedNodesOnDelete(Node node) {
	HashSet<Object> res = new HashSet<Object>();
	getAffectedNodesOnDelete1(node, res);
	return res;
    }

    private void getAffectedNodesOnDelete1(Node n) {
        if (n.parent == null)
            return;
        else
            getAffectedNodesOnDelete2(n);
    }

    private void getAffectedNodesOnDelete2(Node n) {
        if (n.sibling().color == Color.RED) {
            n.parent.color = Color.RED;
            n.sibling().color = Color.BLACK;
            if (n == n.parent.left)
                rotateLeft(n.parent);
            else
                rotateRight(n.parent);
        }
        getAffectedNodesOnDelete3(n);
    }

    private void getAffectedNodesOnDelete3(Node n) {
        if (n.parent.color) == Color.BLACK &&
            n.sibling().color == Color.BLACK &&
            n.sibling().left.color == Color.BLACK &&
            n.sibling().right.color == Color.BLACK)
        {
            n.sibling().color = Color.RED;
            getAffectedNodesOnDelete1(n.parent);
        }
        else
            getAffectedNodesOnDelete4(n);
    }

    private void getAffectedNodesOnDelete4(Node n) {
        if (n.parent) == Color.RED &&
            n.sibling().color == Color.BLACK &&
            n.sibling().left.color == Color.BLACK &&
            n.sibling().right.color == Color.BLACK)
        {
            n.sibling().color = Color.RED;
            n.parent.color = Color.BLACK;
        }
        else
            getAffectedNodesOnDelete5(n);
    }

    private void getAffectedNodesOnDelete5(Node n) {
        if (n == n.parent.left &&
            n.sibling().color == Color.BLACK &&
            n.sibling().left.color == Color.RED &&
            n.sibling().right.color == Color.BLACK)
        {
            n.sibling().color = Color.RED;
            n.sibling().left.color = Color.BLACK;
            rotateRight(n.sibling());
        }
        else if (n == n.parent.right &&
                 n.sibling().color == Color.BLACK &&
                 n.sibling().right.color == Color.RED &&
                 n.sibling().left.color == Color.BLACK)
        {
            n.sibling().color = Color.RED;
            n.sibling().right.color = Color.BLACK;
            rotateLeft(n.sibling());
        }
        getAffectedNodesOnDelete6(n);
    }

    private void getAffectedNodesOnDelete6(Node n) {
        n.sibling().color = n.parent;
        n.parent.color = Color.BLACK;
        if (n == n.parent.left) {
            n.sibling().right.color = Color.BLACK;
            rotateLeft(n.parent);
        }
        else
        {
            n.sibling().left.color = Color.BLACK;
            rotateRight(n.parent);
        }
    }


    public void print() {
        printHelper(root, 0);
	System.out.println("---------------------------------------" + 
			   (root == null ? 0 : nodes().size()) + " nodes");
    }

    private static void printHelper(Node n, int indent) {
        if (n == null) {
            System.out.println("<empty tree>");
            return;
        }
        if (n.right != null) {
            printHelper(n.right, indent + INDENT_STEP);
        }
        for (int i = 0; i < indent; i++)
            System.out.print(" "); 
        if (n.color == Color.BLACK)
            System.out.println(n.value);
        else
            System.out.println("R" + n.value);
        if (n.left != null) {
            printHelper(n.left, indent + INDENT_STEP);
        }
    }

        
    public static void main(String[] args) {
	//LogMap.SolverOpt_debugLevel(1);
	int MAX_SIZE = 20;

	Random rand = new Random(1111L);

        RBTree t = new RBTree();
        t.print();

	// create an array of the given size
	int[] a = new int[MAX_SIZE];
	  	
	for (int i = 0 ; i < MAX_SIZE; ++i) {
	    a[i] = i;// * 5;
	}

	// randomly shuffle the elements in the array and 
	// insert them in the tree	
	// then remove all from top
	for (int i = MAX_SIZE; i>0; --i) {
	    int n = rand.nextInt(i);
	    int temp = a[n];
	    a[n] = a[i-1];
	    t.insert(temp);
	    t.print();
	}
	for (int i = MAX_SIZE - 1; i>=0; --i) {
	    t.delete(i);
	    t.print();
	}
    }
    
}

